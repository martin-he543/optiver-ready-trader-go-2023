<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pubsub API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pubsub</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 Optiver Asia Pacific Pty. Ltd.
#
# This file is part of Ready Trader Go.
#
#     Ready Trader Go is free software: you can redistribute it and/or
#     modify it under the terms of the GNU Affero General Public License
#     as published by the Free Software Foundation, either version 3 of
#     the License, or (at your option) any later version.
#
#     Ready Trader Go is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU Affero General Public License for more details.
#
#     You should have received a copy of the GNU Affero General Public
#     License along with Ready Trader Go.  If not, see
#     &lt;https://www.gnu.org/licenses/&gt;.
import asyncio
import mmap
import os
import struct

from typing import Coroutine, Optional, Tuple, Union

BUFFER_SIZE = 8192
FRAME_HEADER_SIZE = 8
FRAME_SIZE = 128
MAXIMUM_PAYLOAD_LENGTH = FRAME_SIZE - FRAME_HEADER_SIZE


class Publisher(asyncio.WriteTransport):
    &#34;&#34;&#34;Publisher side of a datagram transport based on shared memory.

    Transport is achieved through the use of memory mapped files or shared
    memory blocks. There must be an interval between writes to permit
    subscribers to read the data before it is overwritten.
    &#34;&#34;&#34;
    __slots__ = (&#34;__pack_into&#34;, &#34;_buffer&#34;, &#34;_closed&#34;, &#34;_pos&#34;)

    def __init__(self, buffer: Union[mmap.mmap, memoryview], protocol: asyncio.BaseProtocol):
        super().__init__()
        self._buffer: Optional[Union[mmap.mmap, memoryview]] = buffer
        self._closed: bool = False
        self._pos: int = 0
        asyncio.get_event_loop().call_soon(protocol.connection_made, self)

        self.__pack_into = struct.Struct(&#34;!I&#34;).pack_into

    def __del__(self):
        if not self._closed:
            self.close()

    def abort(self) -&gt; None:
        &#34;&#34;&#34;Close the publisher immediately.&#34;&#34;&#34;
        self.close()

    def can_write_eof(self) -&gt; bool:
        &#34;&#34;&#34;Return False. Publisher&#39;s don&#39;t support writing EOF.&#34;&#34;&#34;
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the publisher.&#34;&#34;&#34;
        self._closed = True

    def write(self, data: Union[bytearray, bytes, memoryview]) -&gt; None:
        &#34;&#34;&#34;Publish the provided data.&#34;&#34;&#34;
        if len(data) &gt; MAXIMUM_PAYLOAD_LENGTH:
            raise ValueError(&#34;payload is longer than maximum payload length&#34;)

        if self._closed:
            return

        # Each frame contains a spinlock (4 bytes), payload length (4 bytes)
        # and payload (up to 120 bytes).
        pos = self._pos
        self.__pack_into(self._buffer, pos + 4, len(data))
        start: int = pos + FRAME_HEADER_SIZE
        self._buffer[start:start + len(data)] = bytes(data)
        self._pos = (pos + FRAME_SIZE) &amp; (BUFFER_SIZE - 1)
        self._buffer[self._pos] = 0
        self._buffer[pos] = 1


class MmapPublisher(Publisher):
    &#34;&#34;&#34;A publisher based on a memory mapped file.&#34;&#34;&#34;
    __slots__ = (&#34;__fileno&#34;,)

    def __init__(self, fileno: int, mm: mmap.mmap, protocol: asyncio.BaseProtocol):
        super().__init__(mm, protocol)
        self.__fileno: Optional[int] = fileno

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the publisher.&#34;&#34;&#34;
        super().close()
        if self._buffer:
            self._buffer.close()
            self._buffer = None
        if self.__fileno:
            os.close(self.__fileno)
            self.__fileno = None


class Subscriber(asyncio.DatagramTransport):
    &#34;&#34;&#34;Subscriber side of a datagram transport based on shared memory.

    Transport is achieved through the use of memory mapped files or shared
    memory blocks. An interval between writes gives subscribers time to read
    the data before it is overwritten and the subscriber polls the shared
    memory in order to pick up changes as soon as possible.
    &#34;&#34;&#34;
    __slots__ = (&#34;_task&#34;, &#34;_closed&#34;, &#34;_protocol&#34;)

    def __init__(self, buffer: Union[mmap.mmap, memoryview], from_addr: Tuple[str, int],
                 protocol: asyncio.DatagramProtocol):
        super().__init__()
        self._closed: bool = False
        self._protocol: asyncio.DatagramProtocol = protocol

        coro: Coroutine = self._subscribe_worker(buffer, from_addr, protocol)
        self._task: asyncio.Task = asyncio.ensure_future(coro)

    async def _subscribe_worker(self, buffer: Union[mmap.mmap, memoryview],
                                from_addr: Tuple[str, int],
                                protocol: asyncio.DatagramProtocol) -&gt; None:
        mask: int = BUFFER_SIZE - 1
        unpack_from = struct.Struct(&#34;!I&#34;).unpack_from
        protocol.connection_made(self)

        try:
            pos: int = 0
            while not self._closed:
                while buffer[pos] == 0:
                    await asyncio.sleep(0.0)
                length, = unpack_from(buffer, pos + 4)
                start: int = pos + FRAME_HEADER_SIZE
                protocol.datagram_received(buffer[start:start + length], from_addr)
                pos = (pos + FRAME_SIZE) &amp; mask
        except asyncio.CancelledError:
            self._protocol.connection_lost(None)
        except Exception as e:
            self._protocol.connection_lost(e)

    def abort(self) -&gt; None:
        &#34;&#34;&#34;Close the transport immediately.&#34;&#34;&#34;
        self.close()

    def is_closing(self):
        &#34;&#34;&#34;Return True if the subscriber is closing or is closed.&#34;&#34;&#34;
        return self._closed

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the subscriber.&#34;&#34;&#34;
        if not self._closed:
            self._task.cancel()
            self._closed = True

    def get_protocol(self) -&gt; asyncio.DatagramProtocol:
        &#34;&#34;&#34;Return the current protocol.&#34;&#34;&#34;
        return self._protocol

    def sendto(self, data: Union[bytearray, bytes, memoryview],
               addr: Optional[Tuple[str, int]] = None) -&gt; None:
        &#34;&#34;&#34;Send data to the transport.&#34;&#34;&#34;
        raise RuntimeError(&#34;Attempt to write to a Subscriber (a read-only transport)&#34;)


class MmapSubscriber(Subscriber):
    &#34;&#34;&#34;A subscriber based on a memory mapped file.&#34;&#34;&#34;
    __slots__ = (&#34;__fileno&#34;, &#34;__mmap&#34;)

    def __init__(self, fileno: int, buffer: mmap.mmap, from_addr: Tuple[str, int],
                 protocol: Optional[asyncio.DatagramProtocol] = None):
        super().__init__(buffer, from_addr, protocol)
        self.__fileno: Optional[int] = fileno
        self.__mmap: Optional[mmap.mmap] = buffer
        self._task.add_done_callback(lambda _: self.__close_mmap())

    def __del__(self):
        self.__close_mmap()

    def __close_mmap(self):
        if self.__mmap:
            self.__mmap.close()
            self.__mmap = None
        if self.__fileno:
            os.close(self.__fileno)
            self.__fileno = None


class PublisherFactory:
    &#34;&#34;&#34;A factory class for Publisher instances.&#34;&#34;&#34;
    def __init__(self, typ: str, name: str):
        if typ not in (&#34;mmap&#34;, &#34;shm&#34;):
            raise ValueError(&#34;type must be either &#39;mmap&#39; or &#39;shm&#39;&#34;)
        self.__typ: str = typ
        self.__name: str = name

    @property
    def name(self):
        &#34;&#34;&#34;Return the name for this publisher factory.&#34;&#34;&#34;
        return self.__name

    @property
    def typ(self):
        &#34;&#34;&#34;Return the type for this publisher factory.&#34;&#34;&#34;
        return self.__typ

    def create(self, protocol: asyncio.BaseProtocol) -&gt; Publisher:
        &#34;&#34;&#34;Create a new Publisher instance.&#34;&#34;&#34;
        if self.__typ == &#34;mmap&#34;:
            fileno = os.open(self.__name, os.O_CREAT | os.O_RDWR)
            os.write(fileno, b&#34;\x00&#34; * BUFFER_SIZE)
            buffer = mmap.mmap(fileno, BUFFER_SIZE, access=mmap.ACCESS_WRITE)
            return MmapPublisher(fileno, buffer, protocol)
        raise RuntimeError(&#34;PublisherFactory type was not &#39;mmap&#39;&#34;)


class SubscriberFactory:
    &#34;&#34;&#34;A factory class for Subscribers.&#34;&#34;&#34;
    def __init__(self, typ: str, name: str):
        if typ not in (&#34;mmap&#34;, &#34;shm&#34;):
            raise ValueError(&#34;type must be either &#39;mmap&#39; or &#39;shm&#39;&#34;)
        self.__typ: str = typ
        self.__name: str = name

    @property
    def name(self):
        &#34;&#34;&#34;Return the name for this subscriber factory.&#34;&#34;&#34;
        return self.__name

    @property
    def typ(self):
        &#34;&#34;&#34;Return the type for this subscriber factory.&#34;&#34;&#34;
        return self.__typ

    def create(self, protocol: Optional[asyncio.DatagramProtocol] = None) -&gt; Subscriber:
        &#34;&#34;&#34;Return a new Subscriber instance.&#34;&#34;&#34;
        if self.__typ == &#34;mmap&#34;:
            fileno = os.open(self.__name, os.O_RDONLY)
            mm = mmap.mmap(fileno, BUFFER_SIZE, access=mmap.ACCESS_READ)
            return MmapSubscriber(fileno, mm, (self.__name, fileno), protocol)
        raise RuntimeError(&#34;SubscriberFactory type was not &#39;mmap&#39;&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pubsub.MmapPublisher"><code class="flex name class">
<span>class <span class="ident">MmapPublisher</span></span>
<span>(</span><span>fileno: int, mm: mmap.mmap, protocol: asyncio.protocols.BaseProtocol)</span>
</code></dt>
<dd>
<div class="desc"><p>A publisher based on a memory mapped file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MmapPublisher(Publisher):
    &#34;&#34;&#34;A publisher based on a memory mapped file.&#34;&#34;&#34;
    __slots__ = (&#34;__fileno&#34;,)

    def __init__(self, fileno: int, mm: mmap.mmap, protocol: asyncio.BaseProtocol):
        super().__init__(mm, protocol)
        self.__fileno: Optional[int] = fileno

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the publisher.&#34;&#34;&#34;
        super().close()
        if self._buffer:
            self._buffer.close()
            self._buffer = None
        if self.__fileno:
            os.close(self.__fileno)
            self.__fileno = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubsub.Publisher" href="#pubsub.Publisher">Publisher</a></li>
<li>asyncio.transports.WriteTransport</li>
<li>asyncio.transports.BaseTransport</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pubsub.Publisher" href="#pubsub.Publisher">Publisher</a></b></code>:
<ul class="hlist">
<li><code><a title="pubsub.Publisher.abort" href="#pubsub.Publisher.abort">abort</a></code></li>
<li><code><a title="pubsub.Publisher.can_write_eof" href="#pubsub.Publisher.can_write_eof">can_write_eof</a></code></li>
<li><code><a title="pubsub.Publisher.close" href="#pubsub.Publisher.close">close</a></code></li>
<li><code><a title="pubsub.Publisher.write" href="#pubsub.Publisher.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pubsub.MmapSubscriber"><code class="flex name class">
<span>class <span class="ident">MmapSubscriber</span></span>
<span>(</span><span>fileno: int, buffer: mmap.mmap, from_addr: Tuple[str, int], protocol: Optional[asyncio.protocols.DatagramProtocol] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A subscriber based on a memory mapped file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MmapSubscriber(Subscriber):
    &#34;&#34;&#34;A subscriber based on a memory mapped file.&#34;&#34;&#34;
    __slots__ = (&#34;__fileno&#34;, &#34;__mmap&#34;)

    def __init__(self, fileno: int, buffer: mmap.mmap, from_addr: Tuple[str, int],
                 protocol: Optional[asyncio.DatagramProtocol] = None):
        super().__init__(buffer, from_addr, protocol)
        self.__fileno: Optional[int] = fileno
        self.__mmap: Optional[mmap.mmap] = buffer
        self._task.add_done_callback(lambda _: self.__close_mmap())

    def __del__(self):
        self.__close_mmap()

    def __close_mmap(self):
        if self.__mmap:
            self.__mmap.close()
            self.__mmap = None
        if self.__fileno:
            os.close(self.__fileno)
            self.__fileno = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubsub.Subscriber" href="#pubsub.Subscriber">Subscriber</a></li>
<li>asyncio.transports.DatagramTransport</li>
<li>asyncio.transports.BaseTransport</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pubsub.Subscriber" href="#pubsub.Subscriber">Subscriber</a></b></code>:
<ul class="hlist">
<li><code><a title="pubsub.Subscriber.abort" href="#pubsub.Subscriber.abort">abort</a></code></li>
<li><code><a title="pubsub.Subscriber.close" href="#pubsub.Subscriber.close">close</a></code></li>
<li><code><a title="pubsub.Subscriber.get_protocol" href="#pubsub.Subscriber.get_protocol">get_protocol</a></code></li>
<li><code><a title="pubsub.Subscriber.is_closing" href="#pubsub.Subscriber.is_closing">is_closing</a></code></li>
<li><code><a title="pubsub.Subscriber.sendto" href="#pubsub.Subscriber.sendto">sendto</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pubsub.Publisher"><code class="flex name class">
<span>class <span class="ident">Publisher</span></span>
<span>(</span><span>buffer: Union[mmap.mmap, memoryview], protocol: asyncio.protocols.BaseProtocol)</span>
</code></dt>
<dd>
<div class="desc"><p>Publisher side of a datagram transport based on shared memory.</p>
<p>Transport is achieved through the use of memory mapped files or shared
memory blocks. There must be an interval between writes to permit
subscribers to read the data before it is overwritten.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Publisher(asyncio.WriteTransport):
    &#34;&#34;&#34;Publisher side of a datagram transport based on shared memory.

    Transport is achieved through the use of memory mapped files or shared
    memory blocks. There must be an interval between writes to permit
    subscribers to read the data before it is overwritten.
    &#34;&#34;&#34;
    __slots__ = (&#34;__pack_into&#34;, &#34;_buffer&#34;, &#34;_closed&#34;, &#34;_pos&#34;)

    def __init__(self, buffer: Union[mmap.mmap, memoryview], protocol: asyncio.BaseProtocol):
        super().__init__()
        self._buffer: Optional[Union[mmap.mmap, memoryview]] = buffer
        self._closed: bool = False
        self._pos: int = 0
        asyncio.get_event_loop().call_soon(protocol.connection_made, self)

        self.__pack_into = struct.Struct(&#34;!I&#34;).pack_into

    def __del__(self):
        if not self._closed:
            self.close()

    def abort(self) -&gt; None:
        &#34;&#34;&#34;Close the publisher immediately.&#34;&#34;&#34;
        self.close()

    def can_write_eof(self) -&gt; bool:
        &#34;&#34;&#34;Return False. Publisher&#39;s don&#39;t support writing EOF.&#34;&#34;&#34;
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the publisher.&#34;&#34;&#34;
        self._closed = True

    def write(self, data: Union[bytearray, bytes, memoryview]) -&gt; None:
        &#34;&#34;&#34;Publish the provided data.&#34;&#34;&#34;
        if len(data) &gt; MAXIMUM_PAYLOAD_LENGTH:
            raise ValueError(&#34;payload is longer than maximum payload length&#34;)

        if self._closed:
            return

        # Each frame contains a spinlock (4 bytes), payload length (4 bytes)
        # and payload (up to 120 bytes).
        pos = self._pos
        self.__pack_into(self._buffer, pos + 4, len(data))
        start: int = pos + FRAME_HEADER_SIZE
        self._buffer[start:start + len(data)] = bytes(data)
        self._pos = (pos + FRAME_SIZE) &amp; (BUFFER_SIZE - 1)
        self._buffer[self._pos] = 0
        self._buffer[pos] = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>asyncio.transports.WriteTransport</li>
<li>asyncio.transports.BaseTransport</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pubsub.MmapPublisher" href="#pubsub.MmapPublisher">MmapPublisher</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pubsub.Publisher.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Close the publisher immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abort(self) -&gt; None:
    &#34;&#34;&#34;Close the publisher immediately.&#34;&#34;&#34;
    self.close()</code></pre>
</details>
</dd>
<dt id="pubsub.Publisher.can_write_eof"><code class="name flex">
<span>def <span class="ident">can_write_eof</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return False. Publisher's don't support writing EOF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_write_eof(self) -&gt; bool:
    &#34;&#34;&#34;Return False. Publisher&#39;s don&#39;t support writing EOF.&#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="pubsub.Publisher.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Close the publisher.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;Close the publisher.&#34;&#34;&#34;
    self._closed = True</code></pre>
</details>
</dd>
<dt id="pubsub.Publisher.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data: Union[bytearray, bytes, memoryview]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Publish the provided data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data: Union[bytearray, bytes, memoryview]) -&gt; None:
    &#34;&#34;&#34;Publish the provided data.&#34;&#34;&#34;
    if len(data) &gt; MAXIMUM_PAYLOAD_LENGTH:
        raise ValueError(&#34;payload is longer than maximum payload length&#34;)

    if self._closed:
        return

    # Each frame contains a spinlock (4 bytes), payload length (4 bytes)
    # and payload (up to 120 bytes).
    pos = self._pos
    self.__pack_into(self._buffer, pos + 4, len(data))
    start: int = pos + FRAME_HEADER_SIZE
    self._buffer[start:start + len(data)] = bytes(data)
    self._pos = (pos + FRAME_SIZE) &amp; (BUFFER_SIZE - 1)
    self._buffer[self._pos] = 0
    self._buffer[pos] = 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubsub.PublisherFactory"><code class="flex name class">
<span>class <span class="ident">PublisherFactory</span></span>
<span>(</span><span>typ: str, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A factory class for Publisher instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PublisherFactory:
    &#34;&#34;&#34;A factory class for Publisher instances.&#34;&#34;&#34;
    def __init__(self, typ: str, name: str):
        if typ not in (&#34;mmap&#34;, &#34;shm&#34;):
            raise ValueError(&#34;type must be either &#39;mmap&#39; or &#39;shm&#39;&#34;)
        self.__typ: str = typ
        self.__name: str = name

    @property
    def name(self):
        &#34;&#34;&#34;Return the name for this publisher factory.&#34;&#34;&#34;
        return self.__name

    @property
    def typ(self):
        &#34;&#34;&#34;Return the type for this publisher factory.&#34;&#34;&#34;
        return self.__typ

    def create(self, protocol: asyncio.BaseProtocol) -&gt; Publisher:
        &#34;&#34;&#34;Create a new Publisher instance.&#34;&#34;&#34;
        if self.__typ == &#34;mmap&#34;:
            fileno = os.open(self.__name, os.O_CREAT | os.O_RDWR)
            os.write(fileno, b&#34;\x00&#34; * BUFFER_SIZE)
            buffer = mmap.mmap(fileno, BUFFER_SIZE, access=mmap.ACCESS_WRITE)
            return MmapPublisher(fileno, buffer, protocol)
        raise RuntimeError(&#34;PublisherFactory type was not &#39;mmap&#39;&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pubsub.PublisherFactory.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return the name for this publisher factory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Return the name for this publisher factory.&#34;&#34;&#34;
    return self.__name</code></pre>
</details>
</dd>
<dt id="pubsub.PublisherFactory.typ"><code class="name">var <span class="ident">typ</span></code></dt>
<dd>
<div class="desc"><p>Return the type for this publisher factory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def typ(self):
    &#34;&#34;&#34;Return the type for this publisher factory.&#34;&#34;&#34;
    return self.__typ</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pubsub.PublisherFactory.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, protocol: asyncio.protocols.BaseProtocol) ‑> <a title="pubsub.Publisher" href="#pubsub.Publisher">Publisher</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Publisher instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, protocol: asyncio.BaseProtocol) -&gt; Publisher:
    &#34;&#34;&#34;Create a new Publisher instance.&#34;&#34;&#34;
    if self.__typ == &#34;mmap&#34;:
        fileno = os.open(self.__name, os.O_CREAT | os.O_RDWR)
        os.write(fileno, b&#34;\x00&#34; * BUFFER_SIZE)
        buffer = mmap.mmap(fileno, BUFFER_SIZE, access=mmap.ACCESS_WRITE)
        return MmapPublisher(fileno, buffer, protocol)
    raise RuntimeError(&#34;PublisherFactory type was not &#39;mmap&#39;&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubsub.Subscriber"><code class="flex name class">
<span>class <span class="ident">Subscriber</span></span>
<span>(</span><span>buffer: Union[mmap.mmap, memoryview], from_addr: Tuple[str, int], protocol: asyncio.protocols.DatagramProtocol)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscriber side of a datagram transport based on shared memory.</p>
<p>Transport is achieved through the use of memory mapped files or shared
memory blocks. An interval between writes gives subscribers time to read
the data before it is overwritten and the subscriber polls the shared
memory in order to pick up changes as soon as possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Subscriber(asyncio.DatagramTransport):
    &#34;&#34;&#34;Subscriber side of a datagram transport based on shared memory.

    Transport is achieved through the use of memory mapped files or shared
    memory blocks. An interval between writes gives subscribers time to read
    the data before it is overwritten and the subscriber polls the shared
    memory in order to pick up changes as soon as possible.
    &#34;&#34;&#34;
    __slots__ = (&#34;_task&#34;, &#34;_closed&#34;, &#34;_protocol&#34;)

    def __init__(self, buffer: Union[mmap.mmap, memoryview], from_addr: Tuple[str, int],
                 protocol: asyncio.DatagramProtocol):
        super().__init__()
        self._closed: bool = False
        self._protocol: asyncio.DatagramProtocol = protocol

        coro: Coroutine = self._subscribe_worker(buffer, from_addr, protocol)
        self._task: asyncio.Task = asyncio.ensure_future(coro)

    async def _subscribe_worker(self, buffer: Union[mmap.mmap, memoryview],
                                from_addr: Tuple[str, int],
                                protocol: asyncio.DatagramProtocol) -&gt; None:
        mask: int = BUFFER_SIZE - 1
        unpack_from = struct.Struct(&#34;!I&#34;).unpack_from
        protocol.connection_made(self)

        try:
            pos: int = 0
            while not self._closed:
                while buffer[pos] == 0:
                    await asyncio.sleep(0.0)
                length, = unpack_from(buffer, pos + 4)
                start: int = pos + FRAME_HEADER_SIZE
                protocol.datagram_received(buffer[start:start + length], from_addr)
                pos = (pos + FRAME_SIZE) &amp; mask
        except asyncio.CancelledError:
            self._protocol.connection_lost(None)
        except Exception as e:
            self._protocol.connection_lost(e)

    def abort(self) -&gt; None:
        &#34;&#34;&#34;Close the transport immediately.&#34;&#34;&#34;
        self.close()

    def is_closing(self):
        &#34;&#34;&#34;Return True if the subscriber is closing or is closed.&#34;&#34;&#34;
        return self._closed

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the subscriber.&#34;&#34;&#34;
        if not self._closed:
            self._task.cancel()
            self._closed = True

    def get_protocol(self) -&gt; asyncio.DatagramProtocol:
        &#34;&#34;&#34;Return the current protocol.&#34;&#34;&#34;
        return self._protocol

    def sendto(self, data: Union[bytearray, bytes, memoryview],
               addr: Optional[Tuple[str, int]] = None) -&gt; None:
        &#34;&#34;&#34;Send data to the transport.&#34;&#34;&#34;
        raise RuntimeError(&#34;Attempt to write to a Subscriber (a read-only transport)&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>asyncio.transports.DatagramTransport</li>
<li>asyncio.transports.BaseTransport</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pubsub.MmapSubscriber" href="#pubsub.MmapSubscriber">MmapSubscriber</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pubsub.Subscriber.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Close the transport immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abort(self) -&gt; None:
    &#34;&#34;&#34;Close the transport immediately.&#34;&#34;&#34;
    self.close()</code></pre>
</details>
</dd>
<dt id="pubsub.Subscriber.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Close the subscriber.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;Close the subscriber.&#34;&#34;&#34;
    if not self._closed:
        self._task.cancel()
        self._closed = True</code></pre>
</details>
</dd>
<dt id="pubsub.Subscriber.get_protocol"><code class="name flex">
<span>def <span class="ident">get_protocol</span></span>(<span>self) ‑> asyncio.protocols.DatagramProtocol</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current protocol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_protocol(self) -&gt; asyncio.DatagramProtocol:
    &#34;&#34;&#34;Return the current protocol.&#34;&#34;&#34;
    return self._protocol</code></pre>
</details>
</dd>
<dt id="pubsub.Subscriber.is_closing"><code class="name flex">
<span>def <span class="ident">is_closing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if the subscriber is closing or is closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closing(self):
    &#34;&#34;&#34;Return True if the subscriber is closing or is closed.&#34;&#34;&#34;
    return self._closed</code></pre>
</details>
</dd>
<dt id="pubsub.Subscriber.sendto"><code class="name flex">
<span>def <span class="ident">sendto</span></span>(<span>self, data: Union[bytearray, bytes, memoryview], addr: Optional[Tuple[str, int]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Send data to the transport.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendto(self, data: Union[bytearray, bytes, memoryview],
           addr: Optional[Tuple[str, int]] = None) -&gt; None:
    &#34;&#34;&#34;Send data to the transport.&#34;&#34;&#34;
    raise RuntimeError(&#34;Attempt to write to a Subscriber (a read-only transport)&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubsub.SubscriberFactory"><code class="flex name class">
<span>class <span class="ident">SubscriberFactory</span></span>
<span>(</span><span>typ: str, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A factory class for Subscribers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubscriberFactory:
    &#34;&#34;&#34;A factory class for Subscribers.&#34;&#34;&#34;
    def __init__(self, typ: str, name: str):
        if typ not in (&#34;mmap&#34;, &#34;shm&#34;):
            raise ValueError(&#34;type must be either &#39;mmap&#39; or &#39;shm&#39;&#34;)
        self.__typ: str = typ
        self.__name: str = name

    @property
    def name(self):
        &#34;&#34;&#34;Return the name for this subscriber factory.&#34;&#34;&#34;
        return self.__name

    @property
    def typ(self):
        &#34;&#34;&#34;Return the type for this subscriber factory.&#34;&#34;&#34;
        return self.__typ

    def create(self, protocol: Optional[asyncio.DatagramProtocol] = None) -&gt; Subscriber:
        &#34;&#34;&#34;Return a new Subscriber instance.&#34;&#34;&#34;
        if self.__typ == &#34;mmap&#34;:
            fileno = os.open(self.__name, os.O_RDONLY)
            mm = mmap.mmap(fileno, BUFFER_SIZE, access=mmap.ACCESS_READ)
            return MmapSubscriber(fileno, mm, (self.__name, fileno), protocol)
        raise RuntimeError(&#34;SubscriberFactory type was not &#39;mmap&#39;&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pubsub.SubscriberFactory.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return the name for this subscriber factory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Return the name for this subscriber factory.&#34;&#34;&#34;
    return self.__name</code></pre>
</details>
</dd>
<dt id="pubsub.SubscriberFactory.typ"><code class="name">var <span class="ident">typ</span></code></dt>
<dd>
<div class="desc"><p>Return the type for this subscriber factory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def typ(self):
    &#34;&#34;&#34;Return the type for this subscriber factory.&#34;&#34;&#34;
    return self.__typ</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pubsub.SubscriberFactory.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, protocol: Optional[asyncio.protocols.DatagramProtocol] = None) ‑> <a title="pubsub.Subscriber" href="#pubsub.Subscriber">Subscriber</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a new Subscriber instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, protocol: Optional[asyncio.DatagramProtocol] = None) -&gt; Subscriber:
    &#34;&#34;&#34;Return a new Subscriber instance.&#34;&#34;&#34;
    if self.__typ == &#34;mmap&#34;:
        fileno = os.open(self.__name, os.O_RDONLY)
        mm = mmap.mmap(fileno, BUFFER_SIZE, access=mmap.ACCESS_READ)
        return MmapSubscriber(fileno, mm, (self.__name, fileno), protocol)
    raise RuntimeError(&#34;SubscriberFactory type was not &#39;mmap&#39;&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pubsub.MmapPublisher" href="#pubsub.MmapPublisher">MmapPublisher</a></code></h4>
</li>
<li>
<h4><code><a title="pubsub.MmapSubscriber" href="#pubsub.MmapSubscriber">MmapSubscriber</a></code></h4>
</li>
<li>
<h4><code><a title="pubsub.Publisher" href="#pubsub.Publisher">Publisher</a></code></h4>
<ul class="">
<li><code><a title="pubsub.Publisher.abort" href="#pubsub.Publisher.abort">abort</a></code></li>
<li><code><a title="pubsub.Publisher.can_write_eof" href="#pubsub.Publisher.can_write_eof">can_write_eof</a></code></li>
<li><code><a title="pubsub.Publisher.close" href="#pubsub.Publisher.close">close</a></code></li>
<li><code><a title="pubsub.Publisher.write" href="#pubsub.Publisher.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubsub.PublisherFactory" href="#pubsub.PublisherFactory">PublisherFactory</a></code></h4>
<ul class="">
<li><code><a title="pubsub.PublisherFactory.create" href="#pubsub.PublisherFactory.create">create</a></code></li>
<li><code><a title="pubsub.PublisherFactory.name" href="#pubsub.PublisherFactory.name">name</a></code></li>
<li><code><a title="pubsub.PublisherFactory.typ" href="#pubsub.PublisherFactory.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubsub.Subscriber" href="#pubsub.Subscriber">Subscriber</a></code></h4>
<ul class="">
<li><code><a title="pubsub.Subscriber.abort" href="#pubsub.Subscriber.abort">abort</a></code></li>
<li><code><a title="pubsub.Subscriber.close" href="#pubsub.Subscriber.close">close</a></code></li>
<li><code><a title="pubsub.Subscriber.get_protocol" href="#pubsub.Subscriber.get_protocol">get_protocol</a></code></li>
<li><code><a title="pubsub.Subscriber.is_closing" href="#pubsub.Subscriber.is_closing">is_closing</a></code></li>
<li><code><a title="pubsub.Subscriber.sendto" href="#pubsub.Subscriber.sendto">sendto</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubsub.SubscriberFactory" href="#pubsub.SubscriberFactory">SubscriberFactory</a></code></h4>
<ul class="">
<li><code><a title="pubsub.SubscriberFactory.create" href="#pubsub.SubscriberFactory.create">create</a></code></li>
<li><code><a title="pubsub.SubscriberFactory.name" href="#pubsub.SubscriberFactory.name">name</a></code></li>
<li><code><a title="pubsub.SubscriberFactory.typ" href="#pubsub.SubscriberFactory.typ">typ</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>